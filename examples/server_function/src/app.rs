use crate::server::*;
use async_trait::async_trait;
use cfg_if::cfg_if;
use leptos::*;
use leptos_meta::*;
use leptos_struct_table::*;
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use std::ops::Range;

// This generates the component BookTable
#[derive(TableComponent, Serialize, Deserialize, Debug, Clone, Default, PartialEq)]
#[table(sortable)]
pub struct Book {
    #[table(key)]
    pub id: u32,
    pub title: String,
    pub author: String,
    pub genre: String,
    pub description: String,
    pub isbn: String,
    pub publication_year: i16,
    pub publisher: String,
}

#[derive(Clone, PartialEq, Debug)]
pub struct BookDataProvider {
    sorting: VecDeque<(BookColumnName, ColumnSort)>,
}

// All we need to load data from a rest api is to implement TableDataProvider and it's `get_rows` methods.
#[async_trait(?Send)]
impl TableDataProvider<Book> for BookDataProvider {
    // BookColumnName is generated by deriving TableComponent. It's an enum with all the column names.
    type ColumnName = BookColumnName;

    // TODO : Error handling
    async fn get_rows(&self, range: Range<usize>) -> Vec<Book> {
        // this would be probably better with some caching for previously loaded data but for
        // simplicity we just load the data every time

        let res = match get_books(self.sorting.clone()).await {
            Ok(books) => books,
            Err(err) => {
                return vec![];
            }
        };

        get_vec_range_clamped(&res, range)
    }

    fn set_sorting(&mut self, sorting: &VecDeque<(Self::ColumnName, ColumnSort)>) {
        self.sorting = sorting.clone();
    }
}

#[component]
pub fn App(cx: Scope) -> impl IntoView {
    provide_meta_context(cx);

    let items = create_rw_signal(
        cx,
        BookDataProvider {
            sorting: VecDeque::from([(BookColumnName::Id, ColumnSort::Descending)]),
        },
    );

    // let current_sorting = create_rw_signal(cx, vec![]);

    let sorting = create_memo(cx, move |_| {
        log!("Sorting: {:?}", items.get());
        items
            .get()
            .sorting
            .iter()
            .map(|(name, sort)| (format!("{name:?}"), format!("{sort:?}")))
            .collect::<Vec<_>>()
    });

    let sort_option_view = create_memo(cx, move |_| {
        if sorting().is_empty() {
            log!("Empty");
            view! {cx,
                <div>
                    "-- No option selected --"
                </div>
            }
            .into_view(cx)
        } else {
            view! {cx,
                <For
                    each=sorting
                    key=|(i, s)| format!("{}-{}", i, s)
                    view=move |cx, (i, s)| {
                        view! {cx,
                            <div>
                                {i}" - "{s}
                            </div>
                        }
                    }
                />
            }
            .into_view(cx)
        }
    });

    view! { cx,
        <div>
            <h5>"Highest Priority"</h5>
                {sort_option_view}
            <h5>"Lowest Priority"</h5>

            <BookTable
                items=items
            />
        </div>
    }
}

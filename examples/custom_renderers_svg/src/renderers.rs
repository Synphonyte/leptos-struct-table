use leptos::*;
use leptos_struct_table::*;

const ROW_HEIGHT: usize = 30;
const ROW_HEIGHT_HALF: usize = ROW_HEIGHT / 2;

#[allow(unused_variables)]
#[component]
pub fn SvgRowRenderer<F, K>(
    cx: Scope,
    #[prop(into)] class: MaybeSignal<String>,
    #[prop(into)] key: K,
    index: usize,
    #[prop(into)] selected: Signal<bool>,
    on_click: F,
    children: Children,
) -> impl IntoView
where
    F: Fn(TableRowEvent<K>) + 'static,
    K: Clone + 'static,
{
    let transform = format!("translate(0, {})", (index + 1) * ROW_HEIGHT);

    view! { cx,
        <g class=class
            transform=transform
            on:click=move |mouse_event| on_click(TableRowEvent {
                key: key.clone(),
                index,
                mouse_event,
            })
        >
            <line x1="5" y1="0" x2="150" y2="0" stroke-width="1px" stroke="black" opacity="0.1" />
            {children(cx)}
        </g>
    }
}

#[component]
pub fn SvgHeadCellRenderer<C, F>(
    cx: Scope,
    /// The class attribute for the head element. Generated by the classes provider.
    #[prop(into)]
    class: Signal<String>,
    /// The class attribute for the inner element. Generated by the classes provider.
    #[prop(into)]
    inner_class: String,
    /// The index of the column. Starts at 0 for the first column. The order of the columns is the same as the order of the fields in the struct.
    index: usize,
    /// The column enum variant. It is auto generated from the struct.
    column: C,
    /// The sort priority of the column. `None` if the column is not sorted. `0` means the column is the primary sort column.
    #[prop(into)]
    sort_priority: Signal<Option<usize>>,
    /// The sort direction of the column. See [`ColumnSort`].
    #[prop(into)]
    sort_direction: Signal<ColumnSort>,
    /// The event handler for the click event. Has to be called with [`TableHeadEvent`].
    on_click: F,
    children: Children,
) -> impl IntoView
where
    F: Fn(TableHeadEvent<C>) + 'static,
    C: 'static + Copy,
{
    let style = move || {
        let sort = match sort_direction() {
            ColumnSort::Ascending => "--sort-icon: '▲';",
            ColumnSort::Descending => "--sort-icon: '▼';",
            ColumnSort::None => "--sort-icon: '';",
        };

        let priority = match sort_priority() {
            Some(priority) => format!("--sort-priority: '{}';", priority + 1),
            None => "--sort-priority: '';".to_string(),
        };

        format!("{} {}", sort, &priority)
    };

    let transform = transform_from_index(index, 0);

    view! { cx,
        <g class=class
            transform=transform
            on:click=move |mouse_event| on_click(TableHeadEvent {
                index,
                column,
                mouse_event,
            })
            style=style
        >
            <text x="0" y=ROW_HEIGHT_HALF class=inner_class dominant-baseline="central">
                {children(cx)}
            </text>
        </g>
    }
}

#[component]
#[allow(unused_variables)]
pub fn SvgTextCellRenderer<T, C>(
    cx: Scope,
    #[prop(into)] class: MaybeSignal<String>,
    #[prop(into)] value: MaybeSignal<T>,
    index: usize,
    on_change: C,
    editable: bool,
) -> impl IntoView
where
    T: IntoView + Clone + 'static,
{
    let x = x_from_index(index);

    view! { cx,
        <text x=x y=ROW_HEIGHT_HALF class=class dominant-baseline="central">{value}</text>
    }
}

#[component]
#[allow(unused_variables)]
pub fn SvgPathCellRenderer<C>(
    cx: Scope,
    #[prop(into)] class: MaybeSignal<String>,
    #[prop(into)] value: MaybeSignal<String>,
    index: usize,
    on_change: C,
    editable: bool,
) -> impl IntoView {
    let transform = transform_from_index(index, 3);

    view! { cx,
        <path transform=transform class=class d=value />
    }
}

fn transform_from_index(index: usize, y: usize) -> String {
    format!("translate({}, {y})", x_from_index(index))
}

fn x_from_index(index: usize) -> usize {
    5 + index * 100
}
